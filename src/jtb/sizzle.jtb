options{  JDK_VERSION = "1.6";  STATIC = true;  JAVA_UNICODE_ESCAPE = true;}PARSER_BEGIN(SizzleParser)package sizzle.parser;public class SizzleParser{}PARSER_END(SizzleParser)SKIP : /* WHITE SPACE */{  " "| "\t"| "\n"| "\r"| "\f"}SPECIAL_TOKEN : /* COMMENTS */{  < SINGLE_LINE_COMMENT :    "#" (~[ "\n", "\r" ])*    (      "\n"    | "\r"    | "\r\n"    ) >}TOKEN :{  < PROTO : "proto" >| < STATIC : "static" >| < MAP : "map" >| < ARRAY : "array" >| < TABLE : "table" >| < OF : "of" >| < EMIT : "emit" >| < FOR : "for" >| < WHILE : "while" >| < WEIGHT : "weight" >| < IF : "if" >| < ELSE : "else" >| < WHEN : "when" >| < SOME : "some" >| < EACH : "each" >| < ALL : "all" >}// Cribbed from the Java 1.1 grammar
TOKEN : /* LITERALS */{  < INTEGER_LITERAL :    < DECIMAL_LITERAL >  | < HEX_LITERAL >  | < OCTAL_LITERAL > >| < #DECIMAL_LITERAL : [ "1"-"9" ] ([ "0"-"9" ])* >| < #HEX_LITERAL : "0" [ "x", "X" ] ([ "0"-"9", "a"-"f", "A"-"F" ])+ >| < #OCTAL_LITERAL : "0" ([ "0"-"7" ])* >| < FLOATING_POINT_LITERAL :    ([ "0"-"9" ])+ "." ([ "0"-"9" ])* (< EXPONENT >)? ([ "f", "F", "d", "D" ])?  | "." ([ "0"-"9" ])+ (< EXPONENT >)? ([ "f", "F", "d", "D" ])?  | ([ "0"-"9" ])+ < EXPONENT > ([ "f", "F", "d", "D" ])?  | ([ "0"-"9" ])+ (< EXPONENT >)? [ "f", "F", "d", "D" ] >| < #EXPONENT : [ "e", "E" ] ([ "+", "-" ])? ([ "0"-"9" ])+ >| < CHARACTER_LITERAL :    "'"    (      (~[ "'", "\\", "\n", "\r" ])    |      (        "\\"        (          [ "n", "t", "b", "r", "f", "\\", "'", "\"" ]        | [ "0"-"7" ] ([ "0"-"7" ])?        | [ "0"-"3" ] [ "0"-"7" ] [ "0"-"7" ]        )      )    )    "'" >| < STRING_LITERAL :    "\""    (      (~[ "\"", "\\", "\n", "\r" ])    |      (        "\\"        (          [ "n", "t", "b", "r", "f", "\\", "'", "\"" ]        | [ "0"-"7" ] ([ "0"-"7" ])?        | [ "0"-"3" ] [ "0"-"7" ] [ "0"-"7" ]        )      )    )*    "\"" >}// Cribbed from the Java 1.1 grammar
TOKEN : /* IDENTIFIERS */{  < IDENTIFIER :    < LETTER >    (      < LETTER >    | < DIGIT >    )* >| < #LETTER : [ "\u0024", "\u0041"-"\u005a", "\u005f", "\u0061"-"\u007a", "\u00c0"-"\u00d6", "\u00d8"-"\u00f6", "\u00f8"-"\u00ff", "\u0100"-"\u1fff", "\u3040"-"\u318f", "\u3300"-"\u337f", "\u3400"-"\u3d2d", "\u4e00"-"\u9fff", "\uf900"-"\ufaff" ] >| < #DIGIT : [ "\u0030"-"\u0039", "\u0660"-"\u0669", "\u06f0"-"\u06f9", "\u0966"-"\u096f", "\u09e6"-"\u09ef", "\u0a66"-"\u0a6f", "\u0ae6"-"\u0aef", "\u0b66"-"\u0b6f", "\u0be7"-"\u0bef", "\u0c66"-"\u0c6f", "\u0ce6"-"\u0cef", "\u0d66"-"\u0d6f", "\u0e50"-"\u0e59", "\u0ed0"-"\u0ed9", "\u1040"-"\u1049" ] >}void Start() :{}{  Program() < EOF >}void Program() :{}{  (    Proto()  )*  (    Statement()  )+}void Proto() :{}{  "proto" StringLiteral()}void Statement() :{}{  Block()| LOOKAHEAD(Identifier() ":" "table")  TableDeclaration()| LOOKAHEAD("static" Identifier() ":")  VariableDeclaration()| LOOKAHEAD(Identifier() ":")  VariableDeclaration()| LOOKAHEAD(Identifier() "=")  AssignmentStatement()| EmitStatement()| IfStatement()| WhileStatement()| ForStatement()| WhenStatement()}void Block() :{}{  "{"  (    Statement()  )*  "}"}void TableDeclaration() :{}{  Identifier() ":" "table" Identifier() [ "(" IntegerLiteral() ")" ]  (    Index()  )*  "of"  (    LOOKAHEAD(Identifier() ":")    Typle()  | Identifier()  | "{" TypleList() "}"  )  [ "weight" Typle() ] ";"}// syntactic sugar to make it easy to parse lists of table indices
void Index() :{}{  "[" Typle() "]"}void Typle() :{}{  Identifier() ":" Identifier()}void TypleList() :{}{  Typle()  (    TypleRest()  )*}void TypleRest() :{}{  "," Typle()}void VariableDeclaration() :{}{  [ "static" ] IdentifierList() ":"  (    Identifier()  | "map" "[" Identifier() "]" "of" Identifier()  | "array" "of" Identifier()  )  [ "=" Initializer() ] ";"}void Initializer() :{}{  (    Expression()  | "{"    [      LOOKAHEAD(Expression() ":")      MappingList()    | ExpressionList()    ]    "}"  )}void MappingList() :{}{  Mapping()  (    MappingRest()  )*}void Mapping() :{}{  Expression() ":" Expression()}void MappingRest() :{}{  "," Mapping()}void AssignmentStatement() :{}{  Assignment() ";"}void Assignment() :{}{  Identifier() "=" Initializer()}void EmitStatement() :{}{  "emit" Identifier()  (    "[" Expression() "]"  )*  "<-" ExpressionList() [ "weight" Expression() ] ";"}void IfStatement() :/*
 * The disambiguating algorithm of JavaCC automatically binds dangling
 * else's to the innermost if statement.  The LOOKAHEAD specification
 * is to tell JavaCC that we know what we are doing.
 */{}{  "if" "(" Expression() ")" Statement()  [    LOOKAHEAD(1)    "else" Statement()  ]}void ForStatement() :{}{  "for" "(" [ AssignmentList() ] ";" [ ExpressionList() ] ";" [ ExpressionList() ] ")" Statement()}void AssignmentList() :{}{  Assignment()  (    AssignmentRest()  )*}void AssignmentRest() :{}{  "," Assignment()}void WhileStatement() :{}{  "while" "(" Expression() ")" Statement()}void WhenStatement() :{}{  "when" "("  (    LOOKAHEAD(IdentifierList() ":")    IdentifierList() ":"    (      "some"    | "each"    | "all"    )    Identifier() ";"  )+  Expression() ")" Statement()}void IdentifierList() :{}{  Identifier()  (    IdentifierRest()  )*}void IdentifierRest() :{}{  "," Identifier()}void Expression() :{}{  ComparisonExpression()  (    (      "&&"    | "||"    )    ComparisonExpression()  )*}void ComparisonExpression() :{}{  PlusExpression()  [    (      "=="    | "!="    | "<"    | ">"    | "<="    | ">="    )    PlusExpression()  ]}void PlusExpression() :{}{  TimesExpression()  (    (      "+"    | "-"    )    TimesExpression()  )*}void TimesExpression() :{}{  UnaryExpression()  (    (      "*"    | "/"    | "%"    )    UnaryExpression()  )*}void UnaryExpression() :{}{  Term()  [    "++"  | "--"  ]}void Term() :{}{  LOOKAHEAD(Identifier() "(")  CallExpression()| LOOKAHEAD(Identifier() ".")  MemberExpression()| LOOKAHEAD(Identifier() "[" Expression() ":")  SliceExpression()| LOOKAHEAD(Identifier() "[")  IndexExpression()| ParentheticalExpression()| Atom()}void CallExpression() :{}{  Identifier() "(" [ ExpressionList() ] ")"}void ExpressionList() :{}{  Expression()  (    ExpressionRest()  )*}void ExpressionRest() :{}{  "," Expression()}void MemberExpression() :{}{  Identifier() "." Identifier()}void SliceExpression() :{}{  Identifier()  (    "[" Expression() ":" Expression() "]"  )*}void IndexExpression() :{}{  Identifier()   [   "[" Expression() "]"   ]}void ParentheticalExpression() :{}{  "(" Expression() ")"}void Atom() :{}{  Identifier()| StringLiteral()| IntegerLiteral()| FloatingPointLiteral()}void Identifier() :{}{  < IDENTIFIER >}void StringLiteral() :{}{  < STRING_LITERAL >}void IntegerLiteral() :{}{  < INTEGER_LITERAL >}void FloatingPointLiteral() :{}{  < FLOATING_POINT_LITERAL >}